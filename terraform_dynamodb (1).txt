# terraform/dynamodb.tf
#
# PURPOSE: Create DynamoDB table for storing current station state
#
# WHY THIS FILE EXISTS:
# - Need fast lookups of station status (DynamoDB = single-digit ms latency)
# - Store only LATEST state (not historical data - that goes to S3)
# - NoSQL design fits our simple key-value pattern
#
# DESIGN CHOICE: Why DynamoDB over RDS?
# - No need for complex queries or joins
# - Event-driven writes (Lambda pushes updates)
# - Auto-scaling without managing servers
# - Cost-effective for this access pattern

# ==============================================================================
# DYNAMODB TABLE FOR STATION STATE
# ==============================================================================

resource "aws_dynamodb_table" "stations" {
  # Table name - must be unique in AWS account + region
  name = "${local.name_prefix}-stations"
  
  # Billing mode determines how you're charged
  # PAY_PER_REQUEST: Charged per read/write operation (good for variable load)
  # PROVISIONED: Pre-allocate capacity (cheaper for consistent high load)
  billing_mode = var.dynamodb_billing_mode
  
  # Primary key (partition key) - how items are uniquely identified
  # WHY station_id: Each station has exactly one current state
  # CONCEPT: Partition key determines which physical partition stores the item
  hash_key = "station_id"
  
  # Optional: Sort key (range key) - not needed for our use case
  # range_key = "timestamp"  # If we wanted to store multiple snapshots per station

  # Define the partition key attribute
  # WHY String: Station IDs like "station-01", "station-42"
  attribute {
    name = "station_id"
    type = "S"  # S = String, N = Number, B = Binary
  }

  # Time To Live (TTL) - automatically delete old items
  # WHY: If a station goes offline, auto-cleanup after X hours
  # NOTE: Commented out for prototype - all data kept indefinitely
  # ttl {
  #   attribute_name = "ttl_timestamp"  # Unix timestamp when item expires
  #   enabled        = true
  # }

  # Point-in-time recovery (backup)
  # WHY: Protects against accidental deletion or data corruption
  # COST: Small additional charge, worth it for production
  point_in_time_recovery {
    enabled = var.environment == "prod" ? true : false  # Only enable in prod
  }

  # Server-side encryption at rest
  # WHY: Data security requirement, usually mandatory for production
  # AWS_OWNED_CMK: Free, AWS manages keys
  # AWS_MANAGED_CMK: Free, more control
  # CUSTOMER_MANAGED_CMK: Most control, costs extra
  server_side_encryption {
    enabled = true
    # kms_key_arn = aws_kms_key.dynamodb.arn  # Optional: custom KMS key
  }

  # Deletion protection - prevents accidental table deletion
  # WHY: Terraform destroy could wipe production data
  deletion_protection_enabled = var.environment == "prod" ? true : false

  # Tags for organization and cost tracking
  tags = merge(
    local.common_tags,
    {
      Name        = "${local.name_prefix}-stations"
      Description = "Current state of all EV battery swap stations"
      DataType    = "station-telemetry"
    }
  )
}

# ==============================================================================
# EXAMPLE ITEM STRUCTURE (for documentation)
# ==============================================================================
# Items in this table will look like:
# {
#   "station_id": "station-01",           // Partition key
#   "battery_available": 12,              // Number of batteries ready
#   "battery_charging": 4,                // Number of batteries charging
#   "temperature": 32.5,                  // Celsius
#   "humidity": 45.2,                     // Percent
#   "status": "operational",              // operational | maintenance | offline
#   "last_swap_time": "2024-01-15T10:30:00Z",
#   "total_swaps_today": 87,
#   "timestamp": "2024-01-15T14:23:45Z",  // Last update time
#   "location": {
#     "latitude": 37.7749,
#     "longitude": -122.4194,
#     "city": "San Francisco"
#   }
# }
#
# WHY THIS STRUCTURE:
# - Denormalized (all data in one item) for fast reads
# - No relationships/joins needed
# - Maps directly to JSON from IoT messages

# ==============================================================================
# OPTIONAL: GLOBAL SECONDARY INDEX (GSI)
# ==============================================================================
# Uncomment if you need to query by status instead of station_id
# WHY: Find all "maintenance" stations without scanning entire table
# COST: GSIs cost extra (additional read/write capacity)
#
# resource "aws_dynamodb_table" "stations" {
#   # ... existing config ...
#   
#   global_secondary_index {
#     name            = "status-index"
#     hash_key        = "status"         # Query by status
#     range_key       = "timestamp"      # Sort by time
#     projection_type = "ALL"            # Include all attributes
#     
#     # For PAY_PER_REQUEST mode, don't specify read/write capacity
#     # For PROVISIONED mode, specify:
#     # read_capacity  = 5
#     # write_capacity = 5
#   }
#   
#   attribute {
#     name = "status"
#     type = "S"
#   }
#   
#   attribute {
#     name = "timestamp"
#     type = "S"
#   }
# }

# ==============================================================================
# CLOUDWATCH ALARMS FOR MONITORING
# ==============================================================================

# Alarm: High read throttling
# WHY: Alerts if table can't keep up with read requests
resource "aws_cloudwatch_metric_alarm" "dynamodb_read_throttle" {
  alarm_name          = "${local.name_prefix}-dynamodb-read-throttle"
  alarm_description   = "Alert when DynamoDB read requests are throttled"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 2
  metric_name         = "ReadThrottleEvents"
  namespace           = "AWS/DynamoDB"
  period              = 300  # 5 minutes
  statistic           = "Sum"
  threshold           = 10   # More than 10 throttled reads in 5 minutes
  treat_missing_data  = "notBreaching"

  dimensions = {
    TableName = aws_dynamodb_table.stations.name
  }

  # In production, add SNS topic for notifications
  # alarm_actions = [aws_sns_topic.alerts.arn]

  tags = local.common_tags
}

# Alarm: High write throttling
resource "aws_cloudwatch_metric_alarm" "dynamodb_write_throttle" {
  alarm_name          = "${local.name_prefix}-dynamodb-write-throttle"
  alarm_description   = "Alert when DynamoDB write requests are throttled"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 2
  metric_name         = "WriteThrottleEvents"
  namespace           = "AWS/DynamoDB"
  period              = 300
  statistic           = "Sum"
  threshold           = 10
  treat_missing_data  = "notBreaching"

  dimensions = {
    TableName = aws_dynamodb_table.stations.name
  }

  tags = local.common_tags
}

# ==============================================================================
# OUTPUTS
# ==============================================================================

output "dynamodb_table_name" {
  description = "Name of the DynamoDB table storing station state"
  value       = aws_dynamodb_table.stations.name
}

output "dynamodb_table_arn" {
  description = "ARN of the DynamoDB table"
  value       = aws_dynamodb_table.stations.arn
}