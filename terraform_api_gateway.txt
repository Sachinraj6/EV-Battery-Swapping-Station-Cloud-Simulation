# terraform/api_gateway.tf
#
# PURPOSE: Create REST API for accessing station data
#
# WHY THIS FILE EXISTS:
# - Provides HTTP interface for querying station status
# - Exposes Lambda functions as REST endpoints
# - Handles request/response transformation
#
# API STRUCTURE:
# - GET /stations          -> List all stations
# - GET /stations/{id}     -> Get specific station
# - OPTIONS /* (CORS)      -> Browser preflight requests

# ==============================================================================
# REST API
# ==============================================================================

# Create REST API
# WHY: Gateway between internet and Lambda functions
resource "aws_api_gateway_rest_api" "stations_api" {
  name        = "${local.name_prefix}-stations-api"
  description = "REST API for EV battery swap station data"
  
  # Endpoint type determines how API is accessed
  # EDGE: CloudFront distribution (globally distributed, lowest latency)
  # REGIONAL: Single region (cheaper, simpler)
  # PRIVATE: VPC only (most secure)
  endpoint_configuration {
    types = ["REGIONAL"]
    # WHY REGIONAL: Simpler for prototype, cheaper than EDGE
    # Production might use EDGE for global users
  }
  
  # API Gateway has limits, but can be increased
  # Default: 10,000 requests/second
  # WHY: Prevents runaway costs from DDoS or bugs
  
  tags = merge(
    local.common_tags,
    {
      Name        = "${local.name_prefix}-stations-api"
      Description = "REST API for station telemetry queries"
    }
  )
}

# ==============================================================================
# API RESOURCES (URL PATHS)
# ==============================================================================

# Root resource is created automatically: /
# We need to create: /stations and /stations/{station_id}

# Resource: /stations
# WHY: Represents collection of stations
resource "aws_api_gateway_resource" "stations" {
  rest_api_id = aws_api_gateway_rest_api.stations_api.id
  parent_id   = aws_api_gateway_rest_api.stations_api.root_resource_id
  path_part   = "stations"
  # Full path: /stations
}

# Resource: /stations/{station_id}
# WHY: Represents individual station (path parameter)
resource "aws_api_gateway_resource" "station_by_id" {
  rest_api_id = aws_api_gateway_rest_api.stations_api.id
  parent_id   = aws_api_gateway_resource.stations.id
  path_part   = "{station_id}"
  # {station_id} is path parameter extracted by API Gateway
  # Full path: /stations/{station_id}
}

# ==============================================================================
# HTTP METHODS: GET /stations
# ==============================================================================

# GET method on /stations
# WHY: Retrieve list of all stations
resource "aws_api_gateway_method" "get_stations" {
  rest_api_id   = aws_api_gateway_rest_api.stations_api.id
  resource_id   = aws_api_gateway_resource.stations.id
  http_method   = "GET"
  authorization = "NONE"
  # WHY NONE: Read-only public API for prototype
  # Production would use: AWS_IAM, COGNITO_USER_POOLS, or custom authorizer
  
  # API Key required (optional security layer)
  # api_key_required = true
}

# Integration: Connect GET /stations to Lambda
# WHY: Tells API Gateway how to invoke backend
resource "aws_api_gateway_integration" "get_stations_lambda" {
  rest_api_id             = aws_api_gateway_rest_api.stations_api.id
  resource_id             = aws_api_gateway_resource.stations.id
  http_method             = aws_api_gateway_method.get_stations.http_method
  integration_http_method = "POST"
  # WHY POST: Lambda invocations always use POST, even for GET APIs
  type                    = "AWS_PROXY"
  # AWS_PROXY: Lambda receives full request, returns full response
  # ALTERNATIVE: AWS (requires request/response templates)
  uri                     = aws_lambda_function.api_handler.invoke_arn
}

# ==============================================================================
# HTTP METHODS: GET /stations/{station_id}
# ==============================================================================

# GET method on /stations/{station_id}
resource "aws_api_gateway_method" "get_station_by_id" {
  rest_api_id   = aws_api_gateway_rest_api.stations_api.id
  resource_id   = aws_api_gateway_resource.station_by_id.id
  http_method   = "GET"
  authorization = "NONE"
  
  # Request parameters
  # WHY: Validates station_id is present in path
  request_parameters = {
    "method.request.path.station_id" = true  # Required
  }
}

# Integration: Connect GET /stations/{station_id} to Lambda
resource "aws_api_gateway_integration" "get_station_by_id_lambda" {
  rest_api_id             = aws_api_gateway_rest_api.stations_api.id
  resource_id             = aws_api_gateway_resource.station_by_id.id
  http_method             = aws_api_gateway_method.get_station_by_id.http_method
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.api_handler.invoke_arn
}

# ==============================================================================
# CORS CONFIGURATION (OPTIONS methods)
# ==============================================================================

# Enable CORS for /stations
# WHY: Browsers require CORS headers for cross-origin requests
resource "aws_api_gateway_method" "options_stations" {
  rest_api_id   = aws_api_gateway_rest_api.stations_api.id
  resource_id   = aws_api_gateway_resource.stations.id
  http_method   = "OPTIONS"
  authorization = "NONE"
}

# Mock integration for OPTIONS (no Lambda needed)
# WHY: CORS preflight doesn't need backend processing
resource "aws_api_gateway_integration" "options_stations" {
  rest_api_id = aws_api_gateway_rest_api.stations_api.id
  resource_id = aws_api_gateway_resource.stations.id
  http_method = aws_api_gateway_method.options_stations.http_method
  type        = "MOCK"
  # MOCK: Returns static response without calling backend
  
  request_templates = {
    "application/json" = "{\"statusCode\": 200}"
  }
}

# CORS response for OPTIONS /stations
resource "aws_api_gateway_method_response" "options_stations_200" {
  rest_api_id = aws_api_gateway_rest_api.stations_api.id
  resource_id = aws_api_gateway_resource.stations.id
  http_method = aws_api_gateway_method.options_stations.http_method
  status_code = "200"
  
  # CORS headers
  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = true
    "method.response.header.Access-Control-Allow-Methods" = true
    "method.response.header.Access-Control-Allow-Origin"  = true
  }
}

# Integration response for OPTIONS /stations
resource "aws_api_gateway_integration_response" "options_stations_200" {
  rest_api_id = aws_api_gateway_rest_api.stations_api.id
  resource_id = aws_api_gateway_resource.stations.id
  http_method = aws_api_gateway_method.options_stations.http_method
  status_code = aws_api_gateway_method_response.options_stations_200.status_code
  
  # CORS header values
  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
    "method.response.header.Access-Control-Allow-Methods" = "'GET,OPTIONS'"
    "method.response.header.Access-Control-Allow-Origin"  = "'*'"
    # WHY *: Allow all origins for prototype
    # Production: Specify exact domain(s)
  }
}

# CORS for /stations/{station_id}
resource "aws_api_gateway_method" "options_station_by_id" {
  rest_api_id   = aws_api_gateway_rest_api.stations_api.id
  resource_id   = aws_api_gateway_resource.station_by_id.id
  http_method   = "OPTIONS"
  authorization = "NONE"
}

resource "aws_api_gateway_integration" "options_station_by_id" {
  rest_api_id = aws_api_gateway_rest_api.stations_api.id
  resource_id = aws_api_gateway_resource.station_by_id.id
  http_method = aws_api_gateway_method.options_station_by_id.http_method
  type        = "MOCK"
  
  request_templates = {
    "application/json" = "{\"statusCode\": 200}"
  }
}

resource "aws_api_gateway_method_response" "options_station_by_id_200" {
  rest_api_id = aws_api_gateway_rest_api.stations_api.id
  resource_id = aws_api_gateway_resource.station_by_id.id
  http_method = aws_api_gateway_method.options_station_by_id.http_method
  status_code = "200"
  
  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = true
    "method.response.header.Access-Control-Allow-Methods" = true
    "method.response.header.Access-Control-Allow-Origin"  = true
  }
}

resource "aws_api_gateway_integration_response" "options_station_by_id_200" {
  rest_api_id = aws_api_gateway_rest_api.stations_api.id
  resource_id = aws_api_gateway_resource.station_by_id.id
  http_method = aws_api_gateway_method.options_station_by_id.http_method
  status_code = aws_api_gateway_method_response.options_station_by_id_200.status_code
  
  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
    "method.response.header.Access-Control-Allow-Methods" = "'GET,OPTIONS'"
    "method.response.header.Access-Control-Allow-Origin"  = "'*'"
  }
}

# ==============================================================================
# API DEPLOYMENT
# ==============================================================================

# Deployment: Publishes API configuration
# WHY: API Gateway requires explicit deployment to make changes live
resource "aws_api_gateway_deployment" "stations_api" {
  rest_api_id = aws_api_gateway_rest_api.stations_api.id
  
  # Trigger redeployment when configuration changes
  # WHY: Ensures latest changes are deployed
  triggers = {
    redeployment = sha1(jsonencode([
      aws_api_gateway_resource.stations.id,
      aws_api_gateway_resource.station_by_id.id,
      aws_api_gateway_method.get_stations.id,
      aws_api_gateway_method.get_station_by_id.id,
      aws_api_gateway_integration.get_stations_lambda.id,
      aws_api_gateway_integration.get_station_by_id_lambda.id,
    ]))
  }
  
  lifecycle {
    create_before_destroy = true
  }
  
  depends_on = [
    aws_api_gateway_integration.get_stations_lambda,
    aws_api_gateway_integration.get_station_by_id_lambda
  ]
}

# Stage: Environment for deployed API (dev, staging, prod)
# WHY: Can have multiple stages of same API
resource "aws_api_gateway_stage" "stations_api" {
  deployment_id = aws_api_gateway_deployment.stations_api.id
  rest_api_id   = aws_api_gateway_rest_api.stations_api.id
  stage_name    = var.environment
  # Creates URL: https://{api-id}.execute-api.{region}.amazonaws.com/{stage}
  
  # Access logging
  # WHY: Track API usage, debug issues, analyze patterns
  access_log_settings {
    destination_arn = aws_cloudwatch_log_group.api_gateway_logs.arn
    format = jsonencode({
      requestId      = "$context.requestId"
      ip             = "$context.identity.sourceIp"
      caller         = "$context.identity.caller"
      user           = "$context.identity.user"
      requestTime    = "$context.requestTime"
      httpMethod     = "$context.httpMethod"
      resourcePath   = "$context.resourcePath"
      status         = "$context.status"
      protocol       = "$context.protocol"
      responseLength = "$context.responseLength"
    })
  }
  
  # Execution logging level
  # WHY: Different levels for different environments
  # ERROR: Only errors (production)
  # INFO: All requests (development/debugging)
  xray_tracing_enabled = var.environment == "prod"
  
  tags = merge(
    local.common_tags,
    {
      Name        = "${local.name_prefix}-api-${var.environment}"
      Description = "API stage for ${var.environment} environment"
    }
  )
}

# CloudWatch log group for API Gateway
resource "aws_cloudwatch_log_group" "api_gateway_logs" {
  name              = "/aws/apigateway/${local.name_prefix}-stations-api"
  retention_in_days = var.cloudwatch_log_retention_days
  
  tags = local.common_tags
}

# Method settings for logging
# WHY: Controls per-method logging configuration
resource "aws_api_gateway_method_settings" "stations_api" {
  rest_api_id = aws_api_gateway_rest_api.stations_api.id
  stage_name  = aws_api_gateway_stage.stations_api.stage_name
  method_path = "*/*"  # Apply to all methods
  
  settings {
    metrics_enabled        = true
    logging_level          = var.environment == "prod" ? "ERROR" : "INFO"
    data_trace_enabled     = var.environment != "prod"  # Full request/response logging
    throttling_burst_limit = 5000   # Max concurrent requests
    throttling_rate_limit  = 10000  # Max requests per second
    # WHY: Protects Lambda from overload, prevents runaway costs
  }
}

# ==============================================================================
# API GATEWAY ACCOUNT SETTINGS
# ==============================================================================

# Configure API Gateway to use CloudWatch logging role
# NOTE: This is account-level, only needs to be set once
resource "aws_api_gateway_account" "main" {
  cloudwatch_role_arn = aws_iam_role.api_gateway_cloudwatch_role.arn
}

# ==============================================================================
# CLOUDWATCH ALARMS
# ==============================================================================

# Alarm: High error rate
resource "aws_cloudwatch_metric_alarm" "api_gateway_errors" {
  alarm_name          = "${local.name_prefix}-api-gateway-errors"
  alarm_description   = "Alert when API has high 5xx error rate"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 2
  metric_name         = "5XXError"
  namespace           = "AWS/ApiGateway"
  period              = 300
  statistic           = "Sum"
  threshold           = 10
  treat_missing_data  = "notBreaching"
  
  dimensions = {
    ApiName = aws_api_gateway_rest_api.stations_api.name
    Stage   = aws_api_gateway_stage.stations_api.stage_name
  }
  
  tags = local.common_tags
}

# Alarm: High latency
resource "aws_cloudwatch_metric_alarm" "api_gateway_latency" {
  alarm_name          = "${local.name_prefix}-api-gateway-latency"
  alarm_description   = "Alert when API latency is high"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 2
  metric_name         = "Latency"
  namespace           = "AWS/ApiGateway"
  period              = 300
  statistic           = "Average"
  threshold           = 1000  # 1 second
  treat_missing_data  = "notBreaching"
  
  dimensions = {
    ApiName = aws_api_gateway_rest_api.stations_api.name
    Stage   = aws_api_gateway_stage.stations_api.stage_name
  }
  
  tags = local.common_tags
}

# ==============================================================================
# OUTPUTS
# ==============================================================================

output "api_gateway_url" {
  description = "Base URL for API Gateway"
  value       = "${aws_api_gateway_stage.stations_api.invoke_url}"
}

output "api_gateway_id" {
  description = "API Gateway REST API ID"
  value       = aws_api_gateway_rest_api.stations_api.id
}

output "api_endpoints" {
  description = "API endpoint URLs"
  value = {
    list_stations = "${aws_api_gateway_stage.stations_api.invoke_url}/stations"
    get_station   = "${aws_api_gateway_stage.stations_api.invoke_url}/stations/{station_id}"
  }
}

# ==============================================================================
# USAGE EXAMPLES (Documentation)
# ==============================================================================

# After deployment, test with:
#
# 1. List all stations:
#    curl https://{api-id}.execute-api.us-east-1.amazonaws.com/dev/stations
#
# 2. Get specific station:
#    curl https://{api-id}.execute-api.us-east-1.amazonaws.com/dev/stations/station-01
#
# 3. Test from browser (CORS enabled):
#    fetch('https://{api-id}.execute-api.us-east-1.amazonaws.com/dev/stations')
#      .then(r => r.json())
#      .then(data => console.log(data))